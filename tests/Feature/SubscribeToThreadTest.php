<?php

namespace Tests\Feature;

use App\Http\Livewire\NewReply;
use App\Http\Livewire\ThreadInformation;
use App\Models\Reply;
use App\Models\Thread;
use App\Models\User;
use App\Notifications\ThreadUpdateNotification;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Notification;
use Livewire\Livewire;
use Tests\TestCase;
use Tests\Traits\RefreshRedis;

class SubscribeToThreadTest extends TestCase
{
    use RefreshDatabase, RefreshRedis;

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $this->session(['skipCaptchaValidation' => true]);
    }

    public function test_user_can_subcribe_thread()
    {
        $user = $this->signIn();
        $thread = create(Thread::class);
        Livewire::actingAs($user)->test(ThreadInformation::class, ['thread' => $thread])->call('toggleSubscribe');

        $thread->replies()->create(['user_id' => $user->id, 'body' => 'test']);

        $this->assertDatabaseHas('thread_subscribed', ['user_id' => $user->id, 'thread_id' => $thread->id]);
    }

    public function test_all_subscriber_receive_notification_when_thread_has_new_reply()
    {
        $user = $this->signIn();
        $thread = create(Thread::class);
        Notification::fake();
        Livewire::actingAs($user)->test(ThreadInformation::class, ['thread' => $thread])->call('toggleSubscribe');

        $another = $this->signIn();

        Livewire::actingAs($another)->test(ThreadInformation::class, ['thread' => $thread])->call('toggleSubscribe');

        Livewire::actingAs($another)->test(NewReply::class, ['thread' => $thread])->set('body', 'test')->call('storeReply');

        Notification::assertSentTo($user, ThreadUpdateNotification::class);
        Notification::assertNotSentTo($another, ThreadUpdateNotification::class);
    }

    public function test_user_can_clear_all_notifications()
    {
        $user = $this->signIn();
        $thread = create(Thread::class);
        $livewire = Livewire::actingAs($user)->test(ThreadInformation::class, ['thread' => $thread])->call('toggleSubscribe');
        $anotherUser = $this->signIn();

        create(Reply::class, ['thread_id' => $thread->id, 'user_id' => $anotherUser->id], 4);
        self::assertCount(4, $user->unreadNotifications);

        $this->signIn($user);
        $livewire->call('clearNotification');
        self::assertCount(0, $user->fresh()->unreadNotifications);
    }

    public function test_user_can_mark_notification_as_read()
    {
        $user = $this->signIn();
        $thread = create(Thread::class);
        $livewire = Livewire::actingAs($user)->test(ThreadInformation::class, ['thread' => $thread])->call('toggleSubscribe');
        $this->signIn();
        create(Reply::class, ['thread_id' => $thread->id], 4);
        self::assertCount(4, $user->unreadNotifications);
        $this->signIn($user);
        $livewire->call('markNotificationAsRead', $user->unreadNotifications->first()->id);
        self::assertCount(3, $user->fresh()->unreadNotifications);
    }

    public function test_all_subscriber_receive_database_notification_when_thread_has_new_reply()
    {
        $thread = create(Thread::class);
        $user = tap(create(User::class))->subscribe($thread);
        $anotherUser = tap(create(User::class))->subscribe($thread);
        $this->signIn();
        create(Reply::class, ['thread_id' => $thread->id], 4);

        self::assertCount(4, $user->fresh()->unreadNotifications);
        $threadNotification = $user->unreadNotifications->first();
        self::assertEquals(ThreadUpdateNotification::class, $threadNotification->type);
        self::assertEquals('creating', $threadNotification->data['type']);

        self::assertCount(4, $anotherUser->unreadNotifications);
        $threadNotification = $anotherUser->unreadNotifications->first();
        self::assertEquals(ThreadUpdateNotification::class, $threadNotification->type);
        self::assertEquals('creating', $threadNotification->data['type']);
    }

    public function test_user_who_subscribe_thread_also_reply_to_that_thread_will_not_receive_database_notification()
    {
        $thread = create(Thread::class);
        $user = tap(create(User::class))->subscribe($thread);
        $this->signIn($user);
        create(Reply::class, ['thread_id' => $thread->id, 'user_id' => $user->id], 4);

        self::assertCount(0, $user->unreadNotifications);
    }

    public function test_thread_owner_will_not_receive_database_notification_when_he_add_new_reply_to_his_thread()
    {
        $thread = create(Thread::class);
        $this->signIn($user = $thread->user);
        create(Reply::class, ['thread_id' => $thread->id, 'user_id' => $user->id], 4);

        self::assertCount(0, $thread->user->fresh()->unreadNotifications);
    }

    public function test_user_will_receive_database_notification_when_there_is_new_reply_in_their_thread()
    {
        $user = create(User::class);
        $thread = create(Thread::class, ['user_id' => $user->id]);
        $this->signIn();
        create(Reply::class, ['thread_id' => $thread->id]);

        self::assertCount(1, $user->unreadNotifications);
    }

}
